# =============================================================================
# CI Pipeline - Optimized for Speed
# =============================================================================
# Optimizations:
# - Shallow git clone (GIT_DEPTH: 5)
# - DAG parallelization - all validate jobs run in parallel (needs: [])
# - Path-based rules - jobs only run when relevant files change
# - Interruptible validation - new commits cancel in-progress MR pipelines
# - Aggressive pip/ansible caching with corruption cleanup
#
# Pipeline structure:
#
#   ┌──────────────┬──────────────┬──────────────┬──────────────┐
#   │              │              │              │              │
#   router:val  zwave:val  sat-2:val  vault:val  moltbot:build  amcrest2mqtt:build (parallel)
#   │              │              │
#   router:deploy zwave:deploy sat-2:deploy (parallel, main only)
#   │
#   vault:configure (main only, after deploy)
#
# =============================================================================

# =============================================================================
# Workflow Configuration
# =============================================================================
workflow:
  auto_cancel:
    on_new_commit: interruptible

variables:
  GIT_DEPTH: 5
  ANSIBLE_HOST_KEY_CHECKING: "False"
  ANSIBLE_PIPELINING: "True"
  PIP_CACHE_DIR: "/cache/pip"
  ANSIBLE_ROLES_PATH: "/cache/ansible-roles"
  MOLTBOT_IMAGE_TAG: "latest"

# =============================================================================
# Path-based change detection
# =============================================================================

.router_changes:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - ansible/router.yml
        - ansible/inventory.yml
        - ansible/roles/configure-base/**/*
        - ansible/roles/configure-docker/**/*
        - ansible/roles/configure-router-network/**/*
        - ansible/roles/configure-wireguard/**/*
        - ansible/roles/configure-notifications/**/*
        - docker/docker-compose.yml
        - docker/**/*
        - networking/**/*
        - base/**/*
        - requirements.txt
        - ansible/requirements.yml
        - .gitlab-ci.yml

.zwave_changes:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - ansible/zwave.yml
        - ansible/inventory.yml
        - ansible/roles/configure-zwave/**/*
        - ansible/roles/configure-snapclient/**/*
        - docker/docker-compose-zwave.yml
        - requirements.txt
        - ansible/requirements.yml
        - .gitlab-ci.yml

.satellite2_changes:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - ansible/satellite-2.yml
        - ansible/inventory.yml
        - ansible/roles/configure-satellite/**/*
        - requirements.txt
        - ansible/requirements.yml
        - .gitlab-ci.yml

# =============================================================================
# Job Templates
# =============================================================================
.interruptible:
  interruptible: true

stages:
  - validate
  - build
  - deploy
  - configure

# =============================================================================
# Base ansible job with caching
# =============================================================================
.ansible:
  image: willhallonline/ansible:latest
  before_script:
    - mkdir -p /cache/pip /cache/ansible-roles
    - pip3 install -q --cache-dir /cache/pip -r requirements.txt
    # Clean corrupted role directories (ansible-galaxy --force doesn't handle this)
    - |
      for d in /cache/ansible-roles/*/; do
        [ -d "$d" ] && [ ! -f "${d}meta/main.yml" ] && [ ! -f "${d}tasks/main.yml" ] && rm -rf "$d" 2>/dev/null
      done
    - ansible-galaxy install -r ansible/requirements.yml -p /cache/ansible-roles --force 2>/dev/null || true
    - mkdir -p ~/.ssh
    - cp ansible/known_hosts ~/.ssh/known_hosts
    - echo ${ROUTER_PRIVATE_KEY_BASE64}|base64 -d > tmp && chmod 600 tmp
  after_script:
    - rm -f tmp
  cache:
    key: "ansible-deps-v2"
    paths:
      - /cache/pip
      - /cache/ansible-roles
    policy: pull-push

# =============================================================================
# Validation Stage - Parallel execution on MRs (DAG)
# =============================================================================
router:validate:
  extends:
    - .ansible
    - .interruptible
    - .router_changes
  stage: validate
  needs: []
  script:
    - ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/router.yml --check --diff

zwave:validate:
  extends:
    - .ansible
    - .interruptible
    - .zwave_changes
  stage: validate
  needs: []
  script:
    - ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/zwave.yml --check --diff

satellite-2:validate:
  extends:
    - .ansible
    - .interruptible
    - .satellite2_changes
  stage: validate
  needs: []
  script:
    - ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/satellite-2.yml --check --diff

# =============================================================================
# Build Stage - Container images (GitLab Registry)
# =============================================================================
# All images are built and pushed to GitLab's built-in container registry.
# Registry URL: gitlab-registry.lab.nkontur.com:443/root/homelab/<image>
# CI variables: $CI_REGISTRY, $CI_REGISTRY_USER, $CI_REGISTRY_PASSWORD, $CI_REGISTRY_IMAGE

.docker_build:
  stage: build
  image: docker:27
  variables:
    DOCKER_HOST: "tcp://10.4.32.2:2375"
    DOCKER_BUILDKIT: "0"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  needs: []

moltbot:build:
  extends: .docker_build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/moltbot:latest -t $CI_REGISTRY_IMAGE/moltbot:$CI_COMMIT_SHORT_SHA docker/moltbot/
    - docker push $CI_REGISTRY_IMAGE/moltbot:latest
    - docker push $CI_REGISTRY_IMAGE/moltbot:$CI_COMMIT_SHORT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - docker/moltbot/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - docker/moltbot/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

amcrest2mqtt:build:
  extends: .docker_build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/amcrest2mqtt:latest -t $CI_REGISTRY_IMAGE/amcrest2mqtt:$CI_COMMIT_SHORT_SHA docker/images/amcrest2mqtt/
    - docker push $CI_REGISTRY_IMAGE/amcrest2mqtt:latest
    - docker push $CI_REGISTRY_IMAGE/amcrest2mqtt:$CI_COMMIT_SHORT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - docker/images/amcrest2mqtt/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - docker/images/amcrest2mqtt/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

snapcast:build:
  extends: .docker_build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/snapcast:latest -t $CI_REGISTRY_IMAGE/snapcast:$CI_COMMIT_SHORT_SHA docker/images/snapcast/
    - docker push $CI_REGISTRY_IMAGE/snapcast:latest
    - docker push $CI_REGISTRY_IMAGE/snapcast:$CI_COMMIT_SHORT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - docker/images/snapcast/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - docker/images/snapcast/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

snapclient:build:
  extends: .docker_build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/snapclient:latest -t $CI_REGISTRY_IMAGE/snapclient:$CI_COMMIT_SHORT_SHA docker/images/snapclient/
    - docker push $CI_REGISTRY_IMAGE/snapclient:latest
    - docker push $CI_REGISTRY_IMAGE/snapclient:$CI_COMMIT_SHORT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - docker/images/snapclient/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - docker/images/snapclient/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

# =============================================================================
# Deploy Stage - Parallel deployment (main only)
# =============================================================================
router:deploy:
  extends: .ansible
  stage: deploy
  resource_group: deploy-router
  needs:
    - job: router:validate
      optional: true
  script:
    - ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/router.yml
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

zwave:deploy:
  extends: .ansible
  stage: deploy
  resource_group: deploy-zwave
  needs:
    - job: zwave:validate
      optional: true
  script:
    - ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/zwave.yml
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

satellite-2:deploy:
  extends: .ansible
  stage: deploy
  resource_group: deploy-satellite-2
  needs:
    - job: satellite-2:validate
      optional: true
  script:
    - ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/satellite-2.yml
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# =============================================================================
# Configure Stage - Terraform (main only, after deploy)
# =============================================================================
vault:configure:
  stage: configure
  image: alpine:3.19
  needs:
    - job: router:deploy
      optional: true
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://vault.lab.nkontur.com:8200
  variables:
    TF_VERSION: "1.7.5"
    VAULT_ADDR: "https://vault.lab.nkontur.com:8200"
    VAULT_SKIP_VERIFY: "true"
  before_script:
    - apk add --no-cache wget unzip curl jq
    - wget -q "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
    - unzip -o "terraform_${TF_VERSION}_linux_amd64.zip" -d /usr/local/bin/
    - chmod +x /usr/local/bin/terraform
  script:
    - cd terraform/vault
    # -------------------------------------------------------------------------
    # Authenticate to Vault via JWT (preferred) or fall back to CI variable.
    #
    # Bootstrap note: the vault-admin policy and JWT role are created by this
    # same Terraform config. On the FIRST run after merging this change, JWT
    # login will fail because the role doesn't exist yet — the fallback
    # VAULT_TOKEN (root) handles that run. Once the vault-admin role is
    # created, all subsequent runs use JWT and the root token can be revoked.
    # -------------------------------------------------------------------------
    - |
      echo "Attempting JWT authentication..."
      JWT_RESPONSE=$(curl -sk --max-time 10 \
        --request POST \
        --data "{\"role\": \"vault-admin\", \"jwt\": \"${VAULT_ID_TOKEN}\"}" \
        "${VAULT_ADDR}/v1/auth/jwt/login" 2>/dev/null) || true

      JWT_TOKEN=$(echo "$JWT_RESPONSE" | jq -r '.auth.client_token // empty' 2>/dev/null)

      if [ -n "$JWT_TOKEN" ]; then
        echo "JWT authentication succeeded — using scoped vault-admin token"
        export VAULT_TOKEN="$JWT_TOKEN"
      elif [ -n "${VAULT_TOKEN:-}" ]; then
        echo "JWT authentication failed — falling back to VAULT_TOKEN CI variable (bootstrap mode)"
      else
        echo "ERROR: No authentication method available"
        echo "JWT response: $JWT_RESPONSE"
        exit 1
      fi
    - |
      terraform init \
        -backend-config="address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault" \
        -backend-config="lock_address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault/lock" \
        -backend-config="unlock_address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault/lock" \
        -backend-config="lock_method=POST" \
        -backend-config="unlock_method=DELETE" \
        -backend-config="username=gitlab-ci-token" \
        -backend-config="password=${CI_JOB_TOKEN}" \
        -backend-config="retry_wait_min=5"
    - terraform validate
    - terraform plan -var="vault_addr=${VAULT_ADDR}" -var="vault_token=${VAULT_TOKEN}" -out=tfplan
    - terraform apply tfplan
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - terraform/vault/**/*

vault:validate:
  extends: .interruptible
  stage: validate
  image: alpine:3.19
  needs: []
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://vault.lab.nkontur.com:8200
  variables:
    TF_VERSION: "1.7.5"
    VAULT_ADDR: "https://vault.lab.nkontur.com:8200"
    VAULT_SKIP_VERIFY: "true"
  before_script:
    - apk add --no-cache wget unzip curl jq
    - wget -q "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
    - unzip -o "terraform_${TF_VERSION}_linux_amd64.zip" -d /usr/local/bin/
    - chmod +x /usr/local/bin/terraform
  script:
    - cd terraform/vault
    # JWT auth with fallback (same logic as vault:configure)
    - |
      echo "Attempting JWT authentication..."
      JWT_RESPONSE=$(curl -sk --max-time 10 \
        --request POST \
        --data "{\"role\": \"vault-admin\", \"jwt\": \"${VAULT_ID_TOKEN}\"}" \
        "${VAULT_ADDR}/v1/auth/jwt/login" 2>/dev/null) || true

      JWT_TOKEN=$(echo "$JWT_RESPONSE" | jq -r '.auth.client_token // empty' 2>/dev/null)

      if [ -n "$JWT_TOKEN" ]; then
        echo "JWT authentication succeeded — using scoped vault-admin token"
        export VAULT_TOKEN="$JWT_TOKEN"
      elif [ -n "${VAULT_TOKEN:-}" ]; then
        echo "JWT authentication failed — falling back to VAULT_TOKEN CI variable (bootstrap mode)"
      else
        echo "ERROR: No authentication method available"
        echo "JWT response: $JWT_RESPONSE"
        exit 1
      fi
    - |
      terraform init \
        -backend-config="address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault" \
        -backend-config="lock_address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault/lock" \
        -backend-config="unlock_address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault/lock" \
        -backend-config="lock_method=POST" \
        -backend-config="unlock_method=DELETE" \
        -backend-config="username=gitlab-ci-token" \
        -backend-config="password=${CI_JOB_TOKEN}" \
        -backend-config="retry_wait_min=5"
    - terraform validate
    - terraform plan -var="vault_addr=${VAULT_ADDR}" -var="vault_token=${VAULT_TOKEN}"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - terraform/vault/**/*
