# =============================================================================
# CI Pipeline - Optimized for Speed
# =============================================================================
# Optimizations:
# - Shallow git clone (GIT_DEPTH: 5)
# - DAG parallelization - all validate jobs run in parallel (needs: [])
# - Path-based rules - jobs only run when relevant files change
# - Interruptible validation - new commits cancel in-progress MR pipelines
# - Aggressive pip/ansible caching with corruption cleanup
#
# Pipeline structure:
#
#   VALIDATE (parallel)
#   ┌────────────────────────┬──────────────┬──────────────┬──────────────┬──────────────────┐
#   router:val [id_tokens]  zwave:val  sat-2:val  vault:validate  jit-approval-svc:test
#
#   BUILD (parallel, path-triggered)
#   ┌──────────────┬──────────────┬──────────────┬──────────────────────┐
#   moltbot:build  amcrest2mqtt:build  snapcast:build  snapclient:build  jit-approval-svc:build
#
#   DEPLOY (main only, parallel)
#   ┌──────────────────────────┬──────────────┬──────────────┬──────────────────────────┐
#   router:deploy [id_tokens]  zwave:deploy [id_tokens]  sat-2:deploy [id_tokens]  vault:configure  vault:rotate [manual]
#   (router:deploy needs vault:configure)
#
#   BOOTSTRAP (main only, manual)
#   ┌──────────────┬──────────────┐
#   router:bootstrap  router:restore
#
# =============================================================================

# =============================================================================
# Workflow Configuration
# =============================================================================
workflow:
  auto_cancel:
    on_new_commit: interruptible

variables:
  GIT_DEPTH: 5
  ANSIBLE_HOST_KEY_CHECKING: "False"
  ANSIBLE_PIPELINING: "True"
  PIP_CACHE_DIR: "/cache/pip"
  ANSIBLE_ROLES_PATH: "/cache/ansible-roles"
  MOLTBOT_IMAGE_TAG: "latest"

# =============================================================================
# Path-based change detection
# =============================================================================

.router_changes:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - ansible/router.yml
        - ansible/inventory.yml
        - ansible/roles/configure-base/**/*
        - ansible/roles/configure-docker/**/*
        - ansible/roles/configure-router-network/**/*
        - ansible/roles/configure-wireguard/**/*
        - ansible/roles/configure-notifications/**/*
        - ansible/roles/fetch-vault-secrets/**/*
        - ansible/roles/restic/**/*
        - docker/docker-compose.yml
        - docker/**/*
        - networking/**/*
        - base/**/*
        - requirements.txt
        - ansible/requirements.yml
        - .gitlab-ci.yml

.zwave_changes:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - ansible/zwave.yml
        - ansible/inventory.yml
        - ansible/roles/configure-zwave/**/*
        - ansible/roles/configure-snapclient/**/*
        - ansible/roles/deploy-compose/**/*
        - docker/docker-compose-zwave.yml
        - docker/docker-compose-observability.yml
        - docker/docker-compose-satellite.yml
        - docker/promtail/satellite-config.yml
        - docker/telegraf/satellite-telegraf.conf
        - requirements.txt
        - ansible/requirements.yml
        - .gitlab-ci.yml

.satellite2_changes:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - ansible/satellite-2.yml
        - ansible/inventory.yml
        - ansible/roles/configure-satellite/**/*
        - ansible/roles/deploy-compose/**/*
        - docker/docker-compose-observability.yml
        - docker/docker-compose-satellite.yml
        - docker/promtail/satellite-config.yml
        - docker/telegraf/satellite-telegraf.conf
        - requirements.txt
        - ansible/requirements.yml
        - .gitlab-ci.yml

# =============================================================================
# Job Templates
# =============================================================================
.interruptible:
  interruptible: true

stages:
  - bootstrap
  - validate
  - build
  - deploy

# =============================================================================
# Bootstrap Stage - Manual disaster recovery (main only)
# =============================================================================
router:bootstrap:
  extends: .ansible
  stage: bootstrap
  environment: admin
  when: manual
  allow_failure: true
  script:
    - ansible-playbook -i ansible/inventory.yml ansible/bootstrap.yml --connection=local
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# =============================================================================
# Base ansible job with caching
# =============================================================================
.ansible:
  image: willhallonline/ansible:latest
  before_script:
    - mkdir -p /cache/pip /cache/ansible-roles
    - pip3 install -q --cache-dir /cache/pip -r requirements.txt
    # Clean corrupted role directories (ansible-galaxy --force doesn't handle this)
    - |
      for d in /cache/ansible-roles/*/; do
        [ -d "$d" ] && [ ! -f "${d}meta/main.yml" ] && [ ! -f "${d}tasks/main.yml" ] && rm -rf "$d" 2>/dev/null
      done
    - ansible-galaxy install -r ansible/requirements.yml -p /cache/ansible-roles --force 2>/dev/null || true
    - mkdir -p ~/.ssh
    - cp ansible/known_hosts ~/.ssh/known_hosts
    # Write SSH key from CI variable (protected — only available on main branch)
    - echo ${ROUTER_PRIVATE_KEY_BASE64}|base64 -d > tmp && chmod 600 tmp
    - |
      if [ ! -s tmp ]; then
        echo "WARN: SSH key is empty (protected variable unavailable on feature branches)"
        export ANSIBLE_SSH_KEY_AVAILABLE=false
      else
        export ANSIBLE_SSH_KEY_AVAILABLE=true
      fi
  after_script:
    - rm -f tmp
  cache:
    key: "ansible-deps-v3"
    paths:
      - /cache/pip
      - /cache/ansible-roles
    policy: pull-push

# =============================================================================
# Validation Stage - Parallel execution on MRs (DAG)
# =============================================================================
router:validate:
  extends:
    - .ansible
    - .interruptible
    - .router_changes
  stage: validate
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://vault.lab.nkontur.com:8200
  needs: []
  script:
    - |
      if [ "$ANSIBLE_SSH_KEY_AVAILABLE" = "true" ]; then
        echo "SSH key available — running full check mode"
        ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/router.yml --check --diff
      else
        echo "SSH key unavailable — running syntax check only"
        ansible-playbook -i ansible/inventory.yml ansible/router.yml --syntax-check
      fi

zwave:validate:
  extends:
    - .ansible
    - .interruptible
    - .zwave_changes
  stage: validate
  needs: []
  script:
    - |
      if [ "$ANSIBLE_SSH_KEY_AVAILABLE" = "true" ]; then
        echo "SSH key available — running full check mode"
        ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/zwave.yml --check --diff
      else
        echo "SSH key unavailable — running syntax check only"
        ansible-playbook -i ansible/inventory.yml ansible/zwave.yml --syntax-check
      fi

satellite-2:validate:
  extends:
    - .ansible
    - .interruptible
    - .satellite2_changes
  stage: validate
  needs: []
  script:
    - |
      if [ "$ANSIBLE_SSH_KEY_AVAILABLE" = "true" ]; then
        echo "SSH key available — running full check mode"
        ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/satellite-2.yml --check --diff
      else
        echo "SSH key unavailable — running syntax check only"
        ansible-playbook -i ansible/inventory.yml ansible/satellite-2.yml --syntax-check
      fi

jit-approval-svc:test:
  extends: .interruptible
  stage: validate
  image: golang:1.22-alpine
  needs: []
  script:
    - cd docker/jit-approval-svc
    - go test -v -count=1 ./...
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - docker/jit-approval-svc/**/*
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - docker/jit-approval-svc/**/*

# =============================================================================
# Build Stage - Container images (GitLab Registry)
# =============================================================================
# All images are built and pushed to GitLab's built-in container registry.
# Registry URL: gitlab-registry.lab.nkontur.com:443/root/homelab/<image>
# CI variables: $CI_REGISTRY, $CI_REGISTRY_USER, $CI_REGISTRY_PASSWORD, $CI_REGISTRY_IMAGE

.docker_build:
  stage: build
  image: docker:27
  variables:
    DOCKER_HOST: "tcp://lab.nkontur.com:2376"
    DOCKER_TLS_VERIFY: "1"
    DOCKER_CERT_PATH: "/certs"
    # Legacy builder required — BuildKit uses APIs not allowed by docker-socket-proxy
    DOCKER_BUILDKIT: "0"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  needs: []

moltbot:build:
  extends: .docker_build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/moltbot:latest -t $CI_REGISTRY_IMAGE/moltbot:$CI_COMMIT_SHORT_SHA docker/moltbot/
    - docker push $CI_REGISTRY_IMAGE/moltbot:latest
    - docker push $CI_REGISTRY_IMAGE/moltbot:$CI_COMMIT_SHORT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - docker/moltbot/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - docker/moltbot/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

amcrest2mqtt:build:
  extends: .docker_build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/amcrest2mqtt:latest -t $CI_REGISTRY_IMAGE/amcrest2mqtt:$CI_COMMIT_SHORT_SHA docker/images/amcrest2mqtt/
    - docker push $CI_REGISTRY_IMAGE/amcrest2mqtt:latest
    - docker push $CI_REGISTRY_IMAGE/amcrest2mqtt:$CI_COMMIT_SHORT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - docker/images/amcrest2mqtt/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - docker/images/amcrest2mqtt/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

snapcast:build:
  extends: .docker_build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/snapcast:latest -t $CI_REGISTRY_IMAGE/snapcast:$CI_COMMIT_SHORT_SHA docker/images/snapcast/
    - docker push $CI_REGISTRY_IMAGE/snapcast:latest
    - docker push $CI_REGISTRY_IMAGE/snapcast:$CI_COMMIT_SHORT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - docker/images/snapcast/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - docker/images/snapcast/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

jit-approval-svc:build:
  extends: .docker_build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/jit-approval-svc:latest -t $CI_REGISTRY_IMAGE/jit-approval-svc:$CI_COMMIT_SHORT_SHA docker/jit-approval-svc/
    - docker push $CI_REGISTRY_IMAGE/jit-approval-svc:latest
    - docker push $CI_REGISTRY_IMAGE/jit-approval-svc:$CI_COMMIT_SHORT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - docker/jit-approval-svc/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - docker/jit-approval-svc/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

snapclient:build:
  extends: .docker_build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/snapclient:latest -t $CI_REGISTRY_IMAGE/snapclient:$CI_COMMIT_SHORT_SHA docker/images/snapclient/
    - docker push $CI_REGISTRY_IMAGE/snapclient:latest
    - docker push $CI_REGISTRY_IMAGE/snapclient:$CI_COMMIT_SHORT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - docker/images/snapclient/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - docker/images/snapclient/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

chromium-browser:build:
  extends: .docker_build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/chromium-browser:latest -t $CI_REGISTRY_IMAGE/chromium-browser:$CI_COMMIT_SHORT_SHA docker/chromium-browser/
    - docker push $CI_REGISTRY_IMAGE/chromium-browser:latest
    - docker push $CI_REGISTRY_IMAGE/chromium-browser:$CI_COMMIT_SHORT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - docker/chromium-browser/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - docker/chromium-browser/**/*
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

# =============================================================================
# Deploy Stage - Parallel deployment (main only)
# =============================================================================
router:deploy:
  extends: .ansible
  stage: deploy
  resource_group: deploy-router
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://vault.lab.nkontur.com:8200
  needs:
    - job: router:validate
      optional: true
    - job: vault:configure
      optional: true
  script:
    - ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/router.yml
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

zwave:deploy:
  extends: .ansible
  stage: deploy
  resource_group: deploy-zwave
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://vault.lab.nkontur.com:8200
  needs:
    - job: zwave:validate
      optional: true
  script:
    - ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/zwave.yml
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

satellite-2:deploy:
  extends: .ansible
  stage: deploy
  resource_group: deploy-satellite-2
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://vault.lab.nkontur.com:8200
  needs:
    - job: satellite-2:validate
      optional: true
  script:
    - ansible-playbook -i ansible/inventory.yml -u root --private-key=tmp ansible/satellite-2.yml
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# =============================================================================
# Vault Configuration - Terraform (main only, deploy stage)
# =============================================================================
vault:configure:
  stage: deploy
  image: alpine:3.19
  environment: admin
  needs: []
  variables:
    TF_VERSION: "1.7.5"
    VAULT_ADDR: "https://vault.lab.nkontur.com:8200"
  before_script:
    - apk add --no-cache wget unzip
    - wget -q "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
    - unzip -o "terraform_${TF_VERSION}_linux_amd64.zip" -d /usr/local/bin/
    - chmod +x /usr/local/bin/terraform
  script:
    - cd terraform/vault
    - |
      terraform init \
        -backend-config="address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault" \
        -backend-config="lock_address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault/lock" \
        -backend-config="unlock_address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault/lock" \
        -backend-config="lock_method=POST" \
        -backend-config="unlock_method=DELETE" \
        -backend-config="username=gitlab-ci-token" \
        -backend-config="password=${CI_JOB_TOKEN}" \
        -backend-config="retry_wait_min=5"
    - terraform validate
    - terraform plan -var="vault_addr=${VAULT_ADDR}" -var="vault_token=${VAULT_TOKEN}" -out=tfplan
    - terraform apply tfplan
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - terraform/vault/**/*

vault:rotate-approles:
  stage: deploy
  image: alpine:3.19
  environment: admin
  needs:
    - job: router:deploy
      optional: true
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://vault.lab.nkontur.com:8200
  variables:
    VAULT_ADDR: "https://vault.lab.nkontur.com:8200"
    VAULT_SKIP_VERIFY: "true"
  when: manual
  allow_failure: true
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      set -euo pipefail

      # --- Helper functions ---
      vault_api() {
        local method="$1" path="$2" data="${3:-}"
        if [ -n "$data" ]; then
          curl -sk --max-time 10 -X "$method" \
            -H "X-Vault-Token: $VAULT_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$data" \
            "${VAULT_ADDR}/v1/${path}"
        else
          curl -sk --max-time 10 -X "$method" \
            -H "X-Vault-Token: $VAULT_TOKEN" \
            "${VAULT_ADDR}/v1/${path}"
        fi
      }

      rotate_approle() {
        local role_name="$1"
        echo ""
        echo "=== Rotating AppRole: ${role_name} ==="

        # Get role_id
        local ROLE_ID_RESP
        ROLE_ID_RESP=$(vault_api GET "auth/approle/role/${role_name}/role-id")
        local ROLE_ID
        ROLE_ID=$(echo "$ROLE_ID_RESP" | jq -r '.data.role_id // empty')
        if [ -z "$ROLE_ID" ]; then
          echo "ERROR: Failed to read role_id for ${role_name}"
          echo "$ROLE_ID_RESP" | jq -r '.errors[]' 2>/dev/null
          return 1
        fi
        echo "  role_id: ${ROLE_ID:0:8}..."

        # Generate new secret_id
        local SECRET_RESP
        SECRET_RESP=$(vault_api POST "auth/approle/role/${role_name}/secret-id")
        local NEW_SECRET_ID
        NEW_SECRET_ID=$(echo "$SECRET_RESP" | jq -r '.data.secret_id // empty')
        if [ -z "$NEW_SECRET_ID" ]; then
          echo "ERROR: Failed to generate secret_id for ${role_name}"
          echo "$SECRET_RESP" | jq -r '.errors[]' 2>/dev/null
          return 1
        fi
        echo "  New secret_id generated"

        # Verify login with new credentials
        local LOGIN_TEST
        LOGIN_TEST=$(curl -sk --max-time 10 -X POST \
          -d "{\"role_id\":\"$ROLE_ID\",\"secret_id\":\"$NEW_SECRET_ID\"}" \
          "${VAULT_ADDR}/v1/auth/approle/login")
        if ! echo "$LOGIN_TEST" | jq -e '.auth.client_token' > /dev/null 2>&1; then
          echo "ERROR: Login verification FAILED for ${role_name} — aborting"
          return 1
        fi
        echo "  Login verification passed"

        # Return values via globals (sh-compatible)
        _ROTATED_ROLE_ID="$ROLE_ID"
        _ROTATED_SECRET_ID="$NEW_SECRET_ID"
        return 0
      }

      # --- Main ---

      echo "=== Authenticating to Vault via JWT ==="
      JWT_RESPONSE=$(curl -sk --max-time 10 \
        --request POST \
        --data "{\"role\": \"vault-admin\", \"jwt\": \"${VAULT_ID_TOKEN}\"}" \
        "${VAULT_ADDR}/v1/auth/jwt/login" 2>/dev/null) || true

      VAULT_TOKEN=$(echo "$JWT_RESPONSE" | jq -r '.auth.client_token // empty' 2>/dev/null)
      if [ -z "$VAULT_TOKEN" ]; then
        echo "JWT authentication failed"
        echo "$JWT_RESPONSE" | jq -r '.errors[]' 2>/dev/null
        exit 1
      fi
      echo "JWT authentication succeeded"

      FAILURES=0

      # -----------------------------------------------------------------
      # 1. Rotate moltbot AppRole (stored in CI variable)
      # -----------------------------------------------------------------
      if rotate_approle "moltbot"; then
        echo "=== Updating moltbot CI variable ==="
        # Fetch GitLab token from Vault for CI variable update
        GL_TOKEN=""
        GL_SECRET_RESP=$(vault_api GET "homelab/data/moltbot/tokens") || true
        GL_TOKEN=$(echo "$GL_SECRET_RESP" | jq -r '.data.data.gitlab_token // empty' 2>/dev/null)
        if [ -n "$GL_TOKEN" ]; then
          echo "  GitLab token fetched from Vault"
        else
          echo "  ERROR: Could not fetch GitLab token from Vault"
          FAILURES=$((FAILURES + 1))
        fi
        unset GL_SECRET_RESP

        if [ -z "$GL_TOKEN" ]; then
          echo "  ERROR: No GitLab token available"
          FAILURES=$((FAILURES + 1))
        else
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X PUT \
            "https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/variables/VAULT_APPROLE_SECRET_ID" \
            -H "PRIVATE-TOKEN: ${GL_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"value\":\"${_ROTATED_SECRET_ID}\",\"protected\":true,\"masked\":true}")
          unset GL_TOKEN

          if [ "$HTTP_CODE" = "200" ]; then
            echo "  CI variable updated ✓"
          else
            echo "  ERROR: Failed to update CI variable (HTTP $HTTP_CODE)"
            FAILURES=$((FAILURES + 1))
          fi
        fi
      else
        FAILURES=$((FAILURES + 1))
      fi

      # -----------------------------------------------------------------
      # 2. Rotate jit-approval-svc AppRole (stored in Vault KV)
      # -----------------------------------------------------------------
      if rotate_approle "jit-approval-svc"; then
        echo "=== Updating jit-approval-svc secrets in Vault ==="
        # Read existing secret to preserve non-approle fields (telegram tokens)
        EXISTING=$(vault_api GET "homelab/data/docker/jit-approval-svc")
        EXISTING_DATA=$(echo "$EXISTING" | jq -r '.data.data // empty' 2>/dev/null)

        if [ -n "$EXISTING_DATA" ] && [ "$EXISTING_DATA" != "null" ]; then
          # Merge: update approle fields, keep everything else
          UPDATED=$(echo "$EXISTING_DATA" | jq \
            --arg rid "$_ROTATED_ROLE_ID" \
            --arg sid "$_ROTATED_SECRET_ID" \
            '. + {approle_role_id: $rid, approle_secret_id: $sid}')
        else
          # First time: create with just approle fields
          echo "  WARN: No existing secret found — creating new entry"
          UPDATED=$(jq -n \
            --arg rid "$_ROTATED_ROLE_ID" \
            --arg sid "$_ROTATED_SECRET_ID" \
            '{approle_role_id: $rid, approle_secret_id: $sid}')
        fi

        WRITE_RESP=$(vault_api POST "homelab/data/docker/jit-approval-svc" \
          "{\"data\": $UPDATED}")

        if echo "$WRITE_RESP" | jq -e '.data.version' > /dev/null 2>&1; then
          VERSION=$(echo "$WRITE_RESP" | jq -r '.data.version')
          echo "  Vault KV updated (version: ${VERSION}) ✓"
        else
          echo "  ERROR: Failed to update Vault KV"
          echo "$WRITE_RESP" | jq -r '.errors[]' 2>/dev/null
          FAILURES=$((FAILURES + 1))
        fi
      else
        FAILURES=$((FAILURES + 1))
      fi

      # -----------------------------------------------------------------
      # Summary
      # -----------------------------------------------------------------
      echo ""
      echo "=== Rotation Summary ==="
      if [ "$FAILURES" -eq 0 ]; then
        echo "All AppRoles rotated successfully ✓"
        echo "  - moltbot: next deploy picks up new secret_id from CI variable"
        echo "  - jit-approval-svc: next deploy picks up new credentials from Vault KV"
      else
        echo "WARNING: ${FAILURES} rotation(s) failed — check logs above"
        exit 1
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

vault:validate:
  extends: .interruptible
  stage: validate
  image: alpine:3.19
  needs: []
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://vault.lab.nkontur.com:8200
  variables:
    TF_VERSION: "1.7.5"
    VAULT_ADDR: "https://vault.lab.nkontur.com:8200"
    VAULT_SKIP_VERIFY: "true"
  before_script:
    - apk add --no-cache wget unzip curl jq
    - wget -q "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
    - unzip -o "terraform_${TF_VERSION}_linux_amd64.zip" -d /usr/local/bin/
    - chmod +x /usr/local/bin/terraform
  script:
    - cd terraform/vault
    - |
      echo "Attempting JWT authentication with vault-read role..."
      JWT_RESPONSE=$(curl -sk --max-time 10 \
        --request POST \
        --data "{\"role\": \"vault-read\", \"jwt\": \"${VAULT_ID_TOKEN}\"}" \
        "${VAULT_ADDR}/v1/auth/jwt/login" 2>/dev/null) || true

      JWT_TOKEN=$(echo "$JWT_RESPONSE" | jq -r '.auth.client_token // empty' 2>/dev/null)

      if [ -n "$JWT_TOKEN" ]; then
        echo "JWT authentication succeeded — using scoped vault-read token"
        export VAULT_TOKEN="$JWT_TOKEN"
      else
        echo "ERROR: JWT authentication failed — no fallback allowed for MR pipelines"
        echo "Ensure the vault-read JWT role is configured and VAULT_ID_TOKEN is available"
        exit 1
      fi
    - |
      terraform init \
        -backend-config="address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault" \
        -backend-config="lock_address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault/lock" \
        -backend-config="unlock_address=https://gitlab.lab.nkontur.com/api/v4/projects/${CI_PROJECT_ID}/terraform/state/vault/lock" \
        -backend-config="lock_method=POST" \
        -backend-config="unlock_method=DELETE" \
        -backend-config="username=gitlab-ci-token" \
        -backend-config="password=${CI_JOB_TOKEN}" \
        -backend-config="retry_wait_min=5"
    - terraform validate
    - terraform plan -lock=false -var="vault_addr=${VAULT_ADDR}" -var="vault_token=${VAULT_TOKEN}"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - terraform/vault/**/*
