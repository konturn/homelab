### Docker socket proxy TLS certificates
# Generate self-signed CA + server + client certs for mTLS between CI runners
# and lab_nginx (which proxies to docker-socket-proxy). Certs are 10-year validity.
- name: Create docker-proxy-tls cert directory
  ansible.builtin.file:
    path: "{{ docker_persistent_data_path }}/docker-proxy-tls"
    state: directory
    mode: '0755'

- name: Check docker-proxy-tls cert files
  ansible.builtin.stat:
    path: "{{ docker_persistent_data_path }}/docker-proxy-tls/{{ item }}"
  loop:
    - ca.pem
    - cert.pem
    - key.pem
    - server-cert.pem
    - server-key.pem
  register: docker_proxy_tls_certs

- name: Purge docker-proxy-tls directory if any cert is missing or a directory
  ansible.builtin.file:
    path: "{{ docker_persistent_data_path }}/docker-proxy-tls"
    state: absent
  when: docker_proxy_tls_certs.results | selectattr('stat.exists', 'equalto', false) | list | length > 0 or
        docker_proxy_tls_certs.results | selectattr('stat.isdir', 'defined') | selectattr('stat.isdir', 'equalto', true) | list | length > 0

- name: Recreate docker-proxy-tls cert directory after purge
  ansible.builtin.file:
    path: "{{ docker_persistent_data_path }}/docker-proxy-tls"
    state: directory
    mode: '0755'

- name: Generate docker-proxy-tls certificates
  ansible.builtin.script:
    cmd: "{{ lookup('env', 'CI_PROJECT_DIR') }}/docker/docker-socket-proxy-tls/generate-certs.sh {{ docker_persistent_data_path }}/docker-proxy-tls"
  when: docker_proxy_tls_certs.results | selectattr('stat.exists', 'equalto', false) | list | length > 0 or
        docker_proxy_tls_certs.results | selectattr('stat.isdir', 'defined') | selectattr('stat.isdir', 'equalto', true) | list | length > 0
  register: docker_proxy_tls_generated

- name: Deploy telegraf sudoers for SMART monitoring
  ansible.builtin.copy:
    content: "telegraf ALL=(root) NOPASSWD: /usr/sbin/smartctl\n"
    dest: /etc/sudoers.d/telegraf
    owner: root
    group: root
    mode: "0440"
    validate: 'visudo -cf %s'
  when: "'router' in inventory_hostname"

### Fix systemd-networkd-wait-online boot timeout
# Default waits for ALL interfaces, causing 2min+ timeout on boot.
# Override to wait only for WAN interface (USB NIC with DHCP).
- name: Create systemd-networkd-wait-online override directory
  ansible.builtin.file:
    path: /etc/systemd/system/systemd-networkd-wait-online.service.d
    state: directory
    owner: root
    group: root
    mode: "0755"
  when: "'router' in inventory_hostname"

- name: Override systemd-networkd-wait-online to wait for WAN interface only
  ansible.builtin.copy:
    content: |
      [Service]
      ExecStart=
      ExecStart=/lib/systemd/systemd-networkd-wait-online --interface=enx6c1ff76b2ec9
    dest: /etc/systemd/system/systemd-networkd-wait-online.service.d/override.conf
    owner: root
    group: root
    mode: "0644"
  when: "'router' in inventory_hostname"

- name: Template out compose file to ansible state directory on host
  ansible.builtin.template:
    src: "{{ lookup('env', 'CI_PROJECT_DIR') + '/docker/' + item }}"
    dest: "{{ docker_compose_dest_path + '/' + item }}"
    owner: root
    group: root
    mode: '0700'
  no_log: true
  loop: "{{ docker_compose_file_names }}"

# nginx configs are now plain conf files committed to the repo in docker/nginx/{hostname}/
# nginx configs are plain conf files committed to the repo

### Generate Loki htpasswd file for push authentication
# Promtail and Docker logging driver authenticate to Loki via nginx reverse proxy
- name: Generate Loki htpasswd file
  ansible.builtin.shell: |
    printf '%s:%s\n' '{{ vault_loki_push_username | default("promtail") }}' \
      "$(openssl passwd -apr1 '{{ vault_loki_push_password | default(lookup("env", "LOKI_PUSH_PASSWORD")) }}')"
  register: loki_htpasswd_content
  delegate_to: localhost
  check_mode: no
  changed_when: false
  no_log: true

- name: Write Loki htpasswd file
  ansible.builtin.copy:
    content: "{{ loki_htpasswd_content.stdout }}"
    dest: "{{ docker_persistent_data_path }}/lab_nginx/conf/loki.htpasswd"
    owner: root
    group: systemd-journal
    mode: '0640'
  no_log: true

- name: Ensure nginx conf directory is traversable by workers
  ansible.builtin.file:
    path: "{{ docker_persistent_data_path }}/lab_nginx/conf"
    state: directory
    mode: '0711'

- name: initialize nginx conf file dicts
  set_fact: 
    docker_config_nginx: []

- name: create nginx conf file dicts
  set_fact:
    docker_config_nginx: "{{ docker_config_nginx + [{'src': 'docker/nginx/nginx.conf',
                        'dest': item.dest + '/conf/nginx.conf',
                        'name': item.name }, 
                         {'src': 'docker/nginx/' + inventory_hostname + '/' + item.network + '_stream.conf',
                        'dest': item.dest + '/conf/conf.d/stream.conf',
                        'name': item.name },
                        {'src': 'docker/nginx/' + inventory_hostname + '/' + item.network +  '_http.conf',
                        'dest': item.dest + '/conf/conf.d/http.conf',
                        'name': item.name },
                        {'src': 'docker/nginx/ssl_config',
                        'dest': item.dest + '/conf/ssl_config',
                        'name': item.name,
                        'owner': 'systemd-resolve',
                        'group': 'systemd-journal',
                        'mode': '0700'  }] }}"
  loop: "{{ nginx_config | default([]) }}"

- name: Create docker conf directories
  ansible.builtin.file:
    path: "{{ item.dest | dirname }}"
    state: directory
  loop: "{{ docker_config + (docker_config_nginx | default([])) }}"

- name: Create docker data directories with specific ownership
  ansible.builtin.file:
    path: "{{ item.path }}"
    state: directory
    owner: "{{ item.owner | default('root') }}"
    group: "{{ item.group | default('root') }}"
    mode: "{{ item.mode | default('0755') }}"
  loop: "{{ docker_data_dirs | default([]) }}"

### Deploy static website files for nkontur.com
- name: Create nkontur.com webroot directory
  ansible.builtin.file:
    path: "{{ docker_persistent_data_path }}/nginx/webroot/nkontur.com"
    state: directory
    mode: '0755'
  when: "'external' in (nginx_config | default([]) | map(attribute='network') | list)"

- name: Synchronize nkontur.com website files
  ansible.posix.synchronize:
    src: "{{ lookup('env', 'CI_PROJECT_DIR') }}/docker/nginx/sites/nkontur.com/"
    dest: "{{ docker_persistent_data_path }}/nginx/webroot/nkontur.com/"
    delete: yes
    recursive: yes
  when: "'external' in (nginx_config | default([]) | map(attribute='network') | list)"

- name: Check if config destinations are directories (cleanup stale state)
  ansible.builtin.stat:
    path: "{{ item.dest }}"
  loop: "{{ docker_config + (docker_config_nginx | default([])) }}"
  register: _config_dest_check

- name: Remove config dest that is a directory instead of a file
  ansible.builtin.file:
    path: "{{ item.stat.path }}"
    state: absent
  loop: "{{ _config_dest_check.results | default([]) }}"
  when: item.stat is defined and item.stat.exists and item.stat.isdir
  loop_control:
    label: "{{ item.stat.path | default('skip') }}"

- name: Copy docker configuration files
  ansible.builtin.template:
    src: "{{ lookup('env', 'CI_PROJECT_DIR') }}/{{ item.src }}"
    dest: "{{ item.dest }}"
    owner: "{{ item.owner | default('root') }}"
    group: "{{ item.owner | default('root') }}"
    mode: "{{ item.mode | default('0640') }}"
  register: docker_config_copy
  loop: "{{ docker_config + (docker_config_nginx | default([])) }}"

- name: Remove old Grafana alerting rules subdirectory
  ansible.builtin.file:
    path: "{{ docker_persistent_data_path }}/grafana/provisioning/alerting/rules"
    state: absent
  when: "'router' in inventory_hostname"

- name: Template Grafana alerting contact points (injects Vault secrets)
  ansible.builtin.template:
    src: "{{ lookup('env', 'CI_PROJECT_DIR') }}/docker/grafana/provisioning/alerting/contactpoints.yml.j2"
    dest: "{{ docker_persistent_data_path }}/grafana/provisioning/alerting/contactpoints.yml"
    owner: root
    group: root
    mode: "0640"
  register: grafana_contactpoints
  when: "'router' in inventory_hostname"

- name: Copy Grafana alerting provisioning files (no Jinja2 templating)
  ansible.builtin.copy:
    src: "{{ lookup('env', 'CI_PROJECT_DIR') }}/{{ item.src }}"
    dest: "{{ item.dest }}"
    owner: root
    group: root
    mode: "0644"
  register: grafana_alerting_copy
  loop:
    - src: "docker/grafana/provisioning/alerting/policies.yml"
      dest: "{{ docker_persistent_data_path }}/grafana/provisioning/alerting/policies.yml"
    - src: "docker/grafana/provisioning/alerting/infrastructure.yml"
      dest: "{{ docker_persistent_data_path }}/grafana/provisioning/alerting/infrastructure.yml"
  when: "'router' in inventory_hostname"

- name: Rebuild Docker images for changed Dockerfiles
  ansible.builtin.command:
    cmd: "docker compose -f {{ docker_compose_dest_path }}/docker-compose.yml build --no-cache {{ item.item.name }}"
  loop: "{{ docker_config_copy.results | selectattr('item.src', 'search', 'Dockerfile$') | selectattr('changed', 'equalto', true) | list }}"
  loop_control:
    label: "{{ item.item.name }}"
  when: not ansible_check_mode

- name: Create and start Docker services
  community.docker.docker_compose_v2:
    project_name: "{{ docker_compose_project_name | default('docker') }}"
    project_src: "{{ docker_compose_dest_path }}/"
    files: "{{ docker_compose_file_names }}"
    state: present
    remove_orphans: true
  timeout: 300
  when: not ansible_check_mode

- name: Force recreate containers after daemon config change
  community.docker.docker_compose_v2:
    project_name: "{{ docker_compose_project_name | default('docker') }}"
    project_src: "{{ docker_compose_dest_path }}/"
    files: "{{ docker_compose_file_names }}"
    state: present
    recreate: always
    remove_orphans: true
  timeout: 300
  when: docker_conf.changed and not ansible_check_mode

- name: Enable dnsmasq.d config loading for Pi-hole
  ansible.builtin.replace:
    path: "{{ docker_persistent_data_path }}/pihole/conf/pihole.toml"
    regexp: '^\s*etc_dnsmasq_d\s*=\s*false'
    replace: '  etc_dnsmasq_d = true'
  register: pihole_dnsmasq_d
  when: not ansible_check_mode
  ignore_errors: yes

- name: Set Pi-hole listening mode to ALL for cross-VLAN DNS
  ansible.builtin.replace:
    path: "{{ docker_persistent_data_path }}/pihole/conf/pihole.toml"
    regexp: '^\s*listeningMode\s*=\s*"LOCAL"'
    replace: '  listeningMode = "ALL"'
  register: pihole_listening_mode
  when: not ansible_check_mode
  ignore_errors: yes

- name: Restart containers if config change
  ansible.builtin.command:
    cmd: "docker restart -t 30 {{ item.item.name }}"
  timeout: 60
  when: item.changed and not ansible_check_mode
  loop: "{{ docker_config_copy.results }}"
  loop_control:
    label: "{{ item.item.name | default('unknown') }} ({{ item.item.src | default('?') }})"
  ignore_errors: yes

- name: Restart Grafana if alerting config changed
  ansible.builtin.command:
    cmd: "docker restart -t 30 grafana"
  timeout: 60
  when: >-
    ((grafana_alerting_copy is defined and grafana_alerting_copy.changed) or
     (grafana_contactpoints is defined and grafana_contactpoints.changed))
    and not ansible_check_mode

- name: Restart pihole if pihole.toml was modified
  ansible.builtin.command:
    cmd: "docker restart -t 30 pihole"
  timeout: 60
  when: (pihole_dnsmasq_d is changed or pihole_listening_mode is changed) and not ansible_check_mode

- name: Configure Pi-hole local DNS records via pihole-FTL
  ansible.builtin.command:
    cmd: >-
      docker exec pihole pihole-FTL --config dns.hosts
      '{{ pihole_dns_hosts | to_json }}'
  when:
    - pihole_dns_hosts is defined
    - not ansible_check_mode
  changed_when: true

# Deluge cache fix: reduce libtorrent disk cache to prevent excessive RAM usage.
# Default cache_size of 512 pieces causes 28GB+ memory consumption with large torrents.
# Repo-managed core.conf sets cache_size to 128, keeping usage under 2GB.
- name: Check if deluge data directory exists
  ansible.builtin.stat:
    path: "{{ docker_persistent_data_path }}/deluge"
  register: deluge_dir

- name: Deploy Deluge core.conf (managed cache_size)
  ansible.builtin.copy:
    src: "{{ lookup('env', 'CI_PROJECT_DIR') + '/docker/deluge/core.conf' }}"
    dest: "{{ docker_persistent_data_path }}/deluge/core.conf"
    owner: root
    group: root
    mode: '0644'
  register: deluge_config
  when: deluge_dir.stat.exists and not ansible_check_mode

- name: Restart deluge if config was modified
  ansible.builtin.command:
    cmd: "docker restart deluge"
  when: deluge_dir.stat.exists and deluge_config is changed and not ansible_check_mode

### OpenClaw config
# Deploy the main OpenClaw config (moltbot.json) from the repo template.
# The template injects the gateway token from Vault.
- name: Deploy OpenClaw config
  ansible.builtin.template:
    src: "{{ lookup('env', 'CI_PROJECT_DIR') }}/docker/moltbot/moltbot.json.j2"
    dest: "{{ docker_persistent_data_path }}/moltbot/data/moltbot.json"
    owner: root
    group: root
    mode: "0600"
  register: openclaw_config
  when: "'router' in inventory_hostname"

- name: Restart OpenClaw gateway if config changed
  ansible.builtin.command:
    cmd: "docker restart moltbot-gateway"
  when: openclaw_config is changed and not ansible_check_mode

### OpenClaw webhook hook transforms
# Deploy hook transform scripts used by the OpenClaw gateway hooks system.
# These parse incoming webhooks (e.g. Grafana alerts) into wake events.
- name: Ensure OpenClaw hooks transforms directory exists
  ansible.builtin.file:
    path: "{{ docker_persistent_data_path }}/moltbot/data/hooks/transforms"
    state: directory
    owner: root
    group: root
    mode: '0755'
  when: "'router' in inventory_hostname"

- name: Deploy OpenClaw hook transforms
  ansible.builtin.copy:
    src: "{{ lookup('env', 'CI_PROJECT_DIR') }}/{{ item.src }}"
    dest: "{{ item.dest }}"
    owner: root
    group: root
    mode: "0644"
  loop:
    - src: "docker/moltbot/hooks/transforms/grafana.js"
      dest: "{{ docker_persistent_data_path }}/moltbot/data/hooks/transforms/grafana.js"
  when: "'router' in inventory_hostname"

### Transcript credential scrubbing cron
# Uses gitleaks (~160 rules) to detect and redact secrets from OpenClaw
# session transcripts. Also purges archived sub-agent transcripts older
# than 7 days. Gitleaks runs natively on the host.
- name: Install gitleaks binary
  ansible.builtin.shell: |
    set -euo pipefail
    GITLEAKS_VERSION="8.30.0"
    DEST="/usr/local/bin/gitleaks"
    if [[ -x "$DEST" ]] && "$DEST" version 2>/dev/null | grep -q "$GITLEAKS_VERSION"; then
      echo "gitleaks ${GITLEAKS_VERSION} already installed"
      exit 0
    fi
    URL="https://github.com/gitleaks/gitleaks/releases/download/v${GITLEAKS_VERSION}/gitleaks_${GITLEAKS_VERSION}_linux_x64.tar.gz"
    TMP=$(mktemp -d)
    curl -fsSL -o "${TMP}/gitleaks.tar.gz" "$URL"
    tar xzf "${TMP}/gitleaks.tar.gz" -C "$TMP" gitleaks
    install -m 0755 "${TMP}/gitleaks" "$DEST"
    rm -rf "$TMP"
  args:
    executable: /bin/bash
  register: gitleaks_install
  changed_when: "'already installed' not in gitleaks_install.stdout"

- name: Create scrub-transcripts config directory
  ansible.builtin.file:
    path: /etc/scrub-transcripts
    state: directory
    owner: root
    group: root
    mode: '0755'

- name: Deploy transcript scrub script
  ansible.builtin.copy:
    src: "{{ lookup('env', 'CI_PROJECT_DIR') + '/docker/scrub-transcripts/scrub-transcripts.sh' }}"
    dest: "/usr/local/bin/scrub-transcripts.sh"
    owner: root
    group: root
    mode: '0755'

- name: Deploy gitleaks config for transcript scrubbing
  ansible.builtin.copy:
    src: "{{ lookup('env', 'CI_PROJECT_DIR') + '/docker/scrub-transcripts/gitleaks-transcripts.toml' }}"
    dest: "/etc/scrub-transcripts/gitleaks-transcripts.toml"
    owner: root
    group: root
    mode: '0644'

- name: Set up transcript scrub cron job (every 10 minutes)
  ansible.builtin.cron:
    name: "Scrub credentials from moltbot transcripts"
    minute: "*/10"
    job: >-
      /usr/local/bin/scrub-transcripts.sh {{ docker_persistent_data_path }}/moltbot/data/agents/main/sessions 2>&1 | logger -t scrub-transcripts

- name: Daily chromium-browser restart (clear tabs and free memory)
  ansible.builtin.cron:
    name: "Restart chromium-browser daily"
    minute: "0"
    hour: "4"
    job: "docker restart chromium-browser 2>&1 | logger -t chromium-restart"
