[[inputs.docker]]
  endpoint = "unix:///var/run/docker.sock"
  
  gather_services = false

  container_name_include = []
  container_name_exclude = []

  timeout = "5s"

  docker_label_include = []
  docker_label_exclude = []

  perdevice_include = ["cpu", "blkio", "network"]

# UPS SNMP monitoring (CyberPower via ups.lab.nkontur.com)
[[inputs.snmp]]
  agents = ["udp://ups.lab.nkontur.com:161"]
  timeout = "5s"
  version = 3
  community = "public"
  agent_host_tag = "source"
  retries = 3
  sec_name = "apc1"
  auth_protocol = "MD5"
  auth_password = "{{ vault_snmp_password | default(lookup('env', 'SNMP_PASSWORD')) }}"
  sec_level = "authPriv"
  priv_protocol = "AES"
  priv_password = "{{ vault_snmp_password | default(lookup('env', 'SNMP_PASSWORD')) }}"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsOutputCurrent.1"
    name = "consumption"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsBatteryTemperature.0"
    name = "temperature"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsOutputPercentLoad.1"
    name = "load"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsOutputVoltage.1"
    name = "voltage"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsEstimatedMinutesRemaining.0"
    name = "minutes"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsEstimatedChargeRemaining.0"
    name = "percent_charge"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsBatteryStatus.0"
    name = "status"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsSecondsOnBattery.0"
    name = "batterySeconds"

[[inputs.ipmi_sensor]]
        path = "/usr/bin/ipmitool"
        servers = ["ADMIN:{{ vault_ipmi_password | default(lookup('env', 'IPMI_PASSWORD')) }}@lan(ipmi.lab.nkontur.com)"]
        interval = "30s"
        timeout = "20s"
[[inputs.cpu]]
    percpu = true
    totalcpu = true
    collect_cpu_time = false
    report_active = true
[[inputs.disk]]
    ignore_fs = ["tmpfs", "devtmpfs", "devfs"]
[[inputs.diskio]]
[[inputs.mem]]
[[inputs.net]]
[[inputs.system]]
[[inputs.swap]]
[[inputs.netstat]]
[[inputs.processes]]
[[inputs.kernel]]
[[inputs.ping]]
  ## Use exec method to avoid CAP_NET_RAW requirement when running as systemd service
  method = "exec"
  interval = "5s"
  urls = ["1.1.1.1", "8.8.8.8", "10.3.0.1"]
  count = 4
  ping_interval = 1.0
  timeout = 2.0
#[[inputs.logparser]]
#  files = ["/var/log/nginx/access.log"]
#  from_beginning = true
#  name_override = "nginx_access_log"
#  [inputs.logparser.grok]
#    patterns = ["%{COMBINED_LOG_FORMAT}"]

# ============================================================================
# SMART Disk Health - Predict failures before they happen
# ============================================================================
[[inputs.smart]]
  path_smartctl = "/usr/sbin/smartctl"
  path_nvme = "/usr/sbin/nvme"
  use_sudo = true
  attributes = true
  interval = "5m"

# ============================================================================
# Hardware Sensors - Temps, fans, voltages (requires lm-sensors)
# ============================================================================
[[inputs.sensors]]

# ============================================================================
# Certificate Expiry - Never get surprised by cert issues
# ============================================================================
[[inputs.x509_cert]]
  sources = [
    "https://grafana.lab.nkontur.com:443",
    "https://gitlab.lab.nkontur.com:443",
    "https://nextcloud.nkontur.com:443",
    "https://plex.nkontur.com:443"
  ]
  interval = "6h"
  timeout = "30s"

# ============================================================================
# DNS Health - Verify DNS resolution is working
# ============================================================================
[[inputs.dns_query]]
  servers = ["127.0.0.1"]
  domains = ["google.com", "cloudflare.com", "github.com"]
  record_type = "A"
  timeout = "5s"
  interval = "60s"

# ============================================================================
# Systemd Services - Track service status
# ============================================================================
[[inputs.systemd_units]]
  unittype = "service"
  pattern = "docker* ssh* telegraf* nginx*"
  timeout = "5s"

# ============================================================================
# GitLab Prometheus Metrics - Scrape /-/metrics endpoint
# ============================================================================
# Collects application-level metrics from GitLab's built-in metrics endpoint.
# Does NOT require the full Prometheus server (disabled in MR !111 for memory).
# Only the monitoring_whitelist in gitlab.rb needs to be set.
#
# Key metrics collected:
#   - puma_*          : Web server connections, workers, thread pool
#   - sidekiq_*       : Background job queue sizes and latencies
#   - gitaly_*        : Git operation performance
#   - gitlab_sql_*    : Database query durations
#   - gitlab_cache_*  : Cache hit/miss rates
#   - ruby_*          : GC stats, memory usage
#   - gitlab_workhorse_* : Request handling and git HTTP sessions
[[inputs.prometheus]]
  urls = ["https://gitlab.lab.nkontur.com/-/metrics"]
  ## Telegraf runs on the router host, not in Docker.
  ## Access GitLab via the nginx proxy (HTTPS) since the container
  ## is on the internal macvlan network without a static IP.
  tls_ca = "/etc/ssl/certs/ca-certificates.crt"
  metric_version = 2
  interval = "60s"
  namepass = ["sidekiq_*", "puma_*", "gitaly_*", "gitlab_sql_*", "gitlab_cache_*", "gitlab_transaction_*", "ruby_*", "gitlab_workhorse_*"]

# ============================================================================
# Pi-hole DNS Stats - Query metrics from Pi-hole API
# ============================================================================
[[inputs.http]]
  urls = ["http://{{ pihole_ip }}:80/admin/api.php?summaryRaw&auth={{ vault_pihole_api_token | default(lookup('env', 'PIHOLE_API_TOKEN')) }}"]
  method = "GET"
  interval = "60s"
  data_format = "json"
  name_override = "pihole"
  json_string_fields = ["status"]

[[outputs.influxdb_v2]]
 ## The URLs of the InfluxDB cluster nodes.
 ##
 ## Multiple URLs can be specified for a single cluster, only ONE of the
 ## urls will be written to each interval.
 ## urls exp: http://127.0.0.1:9999
 ## Use internal Docker network IP for reliable local writes
 urls = ["http://{{ influxdb_ip }}:8086"]

 ## Token for authentication.
 token = "{{ vault_influxdb_telegraf_token | default(lookup('env', 'INFLUXDB_TELEGRAF_TOKEN')) }}"

 ## Organization is the name of the organization you wish to write to; must exist.
 organization = "homelab"

 ## Destination bucket to write into.
 bucket = "metrics"

{% if vault_moltbot_clawrouter_wallet_address is defined and vault_moltbot_clawrouter_wallet_address %}
# ClawRouter USDC wallet balance on Base
[[inputs.exec]]
  commands = ["/etc/telegraf/scripts/clawrouter-balance.sh"]
  timeout = "10s"
  data_format = "influx"
  interval = "30s"
  environment = ["CLAWROUTER_WALLET_ADDRESS={{ vault_moltbot_clawrouter_wallet_address }}"]
{% endif %}

