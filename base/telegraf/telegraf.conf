[[inputs.docker]]
  endpoint = "unix:///var/run/docker.sock"
  
  gather_services = false

  container_name_include = []
  container_name_exclude = []

  timeout = "5s"

  docker_label_include = []
  docker_label_exclude = []

  perdevice_include = ["cpu", "blkio", "network"]

# UPS SNMP monitoring (CyberPower via ups.lab.nkontur.com)
[[inputs.snmp]]
  agents = ["udp://ups.lab.nkontur.com:161"]
  timeout = "5s"
  version = 3
  community = "public"
  agent_host_tag = "source"
  retries = 3
  sec_name = "apc1"
  auth_protocol = "MD5"
  auth_password = "{{ vault_snmp_password | default(lookup('env', 'SNMP_PASSWORD')) }}"
  sec_level = "authPriv"
  priv_protocol = "AES"
  priv_password = "{{ vault_snmp_password | default(lookup('env', 'SNMP_PASSWORD')) }}"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsOutputCurrent.1"
    name = "consumption"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsBatteryTemperature.0"
    name = "temperature"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsOutputPercentLoad.1"
    name = "load"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsOutputVoltage.1"
    name = "voltage"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsEstimatedMinutesRemaining.0"
    name = "minutes"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsEstimatedChargeRemaining.0"
    name = "percent_charge"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsBatteryStatus.0"
    name = "status"
  [[inputs.snmp.field]]
    oid = "UPS-MIB::upsSecondsOnBattery.0"
    name = "batterySeconds"

[[inputs.ipmi_sensor]]
        path = "/usr/bin/ipmitool"
        servers = ["ADMIN:{{ vault_ipmi_password | default(lookup('env', 'IPMI_PASSWORD')) }}@lan(ipmi.lab.nkontur.com)"]
        interval = "30s"
        timeout = "20s"
[[inputs.cpu]]
    percpu = true
    totalcpu = true
    collect_cpu_time = false
    report_active = true
[[inputs.disk]]
    ignore_fs = ["tmpfs", "devtmpfs", "devfs"]
[[inputs.diskio]]
[[inputs.mem]]
[[inputs.net]]
[[inputs.system]]
[[inputs.swap]]
[[inputs.netstat]]
[[inputs.processes]]
[[inputs.kernel]]
[[inputs.ping]]
  ## Use exec method to avoid CAP_NET_RAW requirement when running as systemd service
  method = "exec"
  interval = "5s"
  urls = ["1.1.1.1", "8.8.8.8", "10.3.0.1"]
  count = 4
  ping_interval = 1.0
  timeout = 2.0
#[[inputs.logparser]]
#  files = ["/var/log/nginx/access.log"]
#  from_beginning = true
#  name_override = "nginx_access_log"
#  [inputs.logparser.grok]
#    patterns = ["%{COMBINED_LOG_FORMAT}"]

# ============================================================================
# SMART Disk Health - Predict failures before they happen
# ============================================================================
[[inputs.smart]]
  path_smartctl = "/usr/sbin/smartctl"
  path_nvme = "/usr/sbin/nvme"
  use_sudo = true
  attributes = true
  interval = "5m"

# ============================================================================
# Hardware Sensors - Temps, fans, voltages (requires lm-sensors)
# ============================================================================
[[inputs.sensors]]

# ============================================================================
# Certificate Expiry - Never get surprised by cert issues
# ============================================================================
[[inputs.x509_cert]]
  sources = [
    "https://grafana.lab.nkontur.com:443",
    "https://gitlab.lab.nkontur.com:443",
    "https://nextcloud.nkontur.com:443",
    "https://plex.nkontur.com:443"
  ]
  interval = "6h"
  timeout = "30s"

# ============================================================================
# DNS Health - Verify DNS resolution is working
# ============================================================================
[[inputs.dns_query]]
  servers = ["{{ pihole_ip }}"]
  domains = ["google.com", "cloudflare.com", "github.com"]
  record_type = "A"
  timeout = "5s"
  interval = "60s"

# ============================================================================
# Systemd Services - Track service status
# ============================================================================
[[inputs.systemd_units]]
  unittype = "service"
  pattern = "docker* ssh* telegraf* nginx*"
  timeout = "5s"

# ============================================================================
# GitLab Prometheus Metrics - Scrape /-/metrics endpoint
# ============================================================================
# Collects application-level metrics from GitLab's built-in metrics endpoint.
# Does NOT require the full Prometheus server (disabled in MR !111 for memory).
# Only the monitoring_whitelist in gitlab.rb needs to be set.
#
# Key metrics collected:
#   - puma_*          : Web server connections, workers, thread pool
#   - sidekiq_*       : Background job queue sizes and latencies
#   - gitaly_*        : Git operation performance
#   - gitlab_sql_*    : Database query durations
#   - gitlab_cache_*  : Cache hit/miss rates
#   - ruby_*          : GC stats, memory usage
#   - gitlab_workhorse_* : Request handling and git HTTP sessions
[[inputs.prometheus]]
  urls = ["https://gitlab.lab.nkontur.com/-/metrics"]
  ## Telegraf runs on the router host, not in Docker.
  ## Access GitLab via the nginx proxy (HTTPS) since the container
  ## is on the internal macvlan network without a static IP.
  tls_ca = "/etc/ssl/certs/ca-certificates.crt"
  metric_version = 2
  interval = "60s"
  namepass = ["sidekiq_*", "puma_*", "gitaly_*", "gitlab_sql_*", "gitlab_cache_*", "gitlab_transaction_*", "ruby_*", "gitlab_workhorse_*"]

# ============================================================================
# Pi-hole — DNS query stats (v6 API with token auth)
# ============================================================================
# Pi-hole v6 app password — script authenticates via /api/auth, then cleans up session.
[[inputs.exec]]
  commands = ["/etc/telegraf/scripts/pihole-stats.sh"]
  timeout = "10s"
  data_format = "influx"
  interval = "30s"
  environment = [
    "PIHOLE_URL=http://{{ pihole_ip }}",
    "PIHOLE_API_TOKEN={{ vault_pihole_api_token | default(lookup('env', 'PIHOLE_API_TOKEN')) }}"
  ]

# ============================================================================
# Nginx — Request rates and connection stats via stub_status
# ============================================================================
# Requires stub_status enabled on each nginx instance.
# See networking/nginx notes — add a /stub_status location block.
[[inputs.nginx]]
  urls = ["http://{{ lab_nginx_ip }}/stub_status"]
  interval = "30s"
  response_timeout = "5s"
  [inputs.nginx.tags]
    nginx_instance = "lab"

[[inputs.nginx]]
  urls = ["http://{{ nginx_ip }}/stub_status"]
  interval = "30s"
  response_timeout = "5s"
  [inputs.nginx.tags]
    nginx_instance = "external"

[[inputs.nginx]]
  urls = ["http://{{ iot_nginx_ip }}/stub_status"]
  interval = "30s"
  response_timeout = "5s"
  [inputs.nginx.tags]
    nginx_instance = "iot"

# ============================================================================
# Sonarr — Queue depth and system status
# ============================================================================
[[inputs.http]]
  urls = ["https://sonarr.lab.nkontur.com/api/v3/queue?apikey={{ vault_sonarr_api_key | default(lookup('env', 'SONARR_API_KEY')) }}"]
  method = "GET"
  interval = "5m"
  timeout = "10s"
  insecure_skip_verify = true
  data_format = "json_v2"
  name_override = "sonarr_queue"
  [[inputs.http.json_v2]]
    [[inputs.http.json_v2.field]]
      path = "totalRecords"
      rename = "total_records"
      type = "int"

[[inputs.http]]
  urls = ["https://sonarr.lab.nkontur.com/api/v3/wanted/missing?apikey={{ vault_sonarr_api_key | default(lookup('env', 'SONARR_API_KEY')) }}&pageSize=1"]
  method = "GET"
  interval = "5m"
  timeout = "10s"
  insecure_skip_verify = true
  data_format = "json_v2"
  name_override = "sonarr_missing"
  [[inputs.http.json_v2]]
    [[inputs.http.json_v2.field]]
      path = "totalRecords"
      rename = "total_records"
      type = "int"

[[inputs.http]]
  urls = ["https://sonarr.lab.nkontur.com/api/v3/system/status?apikey={{ vault_sonarr_api_key | default(lookup('env', 'SONARR_API_KEY')) }}"]
  method = "GET"
  interval = "5m"
  timeout = "10s"
  insecure_skip_verify = true
  data_format = "json_v2"
  name_override = "sonarr_status"
  [[inputs.http.json_v2]]
    [[inputs.http.json_v2.field]]
      path = "version"
      type = "string"

# ============================================================================
# Radarr — Queue depth and system status
# ============================================================================
[[inputs.http]]
  urls = ["https://radarr.lab.nkontur.com/api/v3/queue?apikey={{ vault_radarr_api_key | default(lookup('env', 'RADARR_API_KEY')) }}"]
  method = "GET"
  interval = "5m"
  timeout = "10s"
  insecure_skip_verify = true
  data_format = "json_v2"
  name_override = "radarr_queue"
  [[inputs.http.json_v2]]
    [[inputs.http.json_v2.field]]
      path = "totalRecords"
      rename = "total_records"
      type = "int"

[[inputs.http]]
  urls = ["https://radarr.lab.nkontur.com/api/v3/wanted/missing?apikey={{ vault_radarr_api_key | default(lookup('env', 'RADARR_API_KEY')) }}&pageSize=1"]
  method = "GET"
  interval = "5m"
  timeout = "10s"
  insecure_skip_verify = true
  data_format = "json_v2"
  name_override = "radarr_missing"
  [[inputs.http.json_v2]]
    [[inputs.http.json_v2.field]]
      path = "totalRecords"
      rename = "total_records"
      type = "int"

[[inputs.http]]
  urls = ["https://radarr.lab.nkontur.com/api/v3/system/status?apikey={{ vault_radarr_api_key | default(lookup('env', 'RADARR_API_KEY')) }}"]
  method = "GET"
  interval = "5m"
  timeout = "10s"
  insecure_skip_verify = true
  data_format = "json_v2"
  name_override = "radarr_status"
  [[inputs.http.json_v2]]
    [[inputs.http.json_v2.field]]
      path = "version"
      type = "string"

# ============================================================================
# NZBGet — Download speed and queue stats via JSON-RPC
# ============================================================================
[[inputs.http]]
  urls = ["https://{{ vault_nzbget_username | default(lookup('env', 'NZBGET_USERNAME')) }}:{{ vault_nzbget_password | default(lookup('env', 'NZBGET_PASSWORD')) }}@nzbget.lab.nkontur.com/jsonrpc/status"]
  insecure_skip_verify = true
  method = "GET"
  interval = "30s"
  timeout = "5s"
  data_format = "json_v2"
  name_override = "nzbget"
  [[inputs.http.json_v2]]
    [[inputs.http.json_v2.object]]
      path = "result"
      disable_prepend_keys = true
    [[inputs.http.json_v2.field]]
      path = "result.DownloadRate"
      rename = "download_rate"
      type = "int"
    [[inputs.http.json_v2.field]]
      path = "result.RemainingSizeMB"
      rename = "remaining_size_mb"
      type = "int"
    [[inputs.http.json_v2.field]]
      path = "result.DownloadedSizeMB"
      rename = "downloaded_size_mb"
      type = "int"
    [[inputs.http.json_v2.field]]
      path = "result.ServerPaused"
      rename = "server_paused"
      type = "boolean"
    [[inputs.http.json_v2.field]]
      path = "result.PostJobCount"
      rename = "post_job_count"
      type = "int"

# ============================================================================
# Deluge — Download/upload speed and torrent queue via web API
# ============================================================================
# Deluge web API requires session auth. Use an exec script to handle login + stats.
[[inputs.exec]]
  commands = ["/etc/telegraf/scripts/deluge-stats.sh"]
  timeout = "10s"
  data_format = "influx"
  interval = "30s"
  environment = [
    "DELUGE_PASSWORD={{ vault_deluge_password | default(lookup('env', 'DELUGE_PASSWORD')) }}",
    "DELUGE_HOST={{ deluge_ip }}"
  ]

# ============================================================================
# Plex/Tautulli — Active streams and transcode stats
# ============================================================================
# Requires Tautulli to be running. If not yet deployed, these inputs will
# gracefully fail until the service is available.
{% if vault_tautulli_api_key is defined and vault_tautulli_api_key %}
[[inputs.http]]
  urls = ["https://tautulli.lab.nkontur.com/api/v2?apikey={{ vault_tautulli_api_key }}&cmd=get_activity"]
  method = "GET"
  interval = "30s"
  timeout = "5s"
  data_format = "json_v2"
  name_override = "tautulli_activity"
  [[inputs.http.json_v2]]
    [[inputs.http.json_v2.field]]
      path = "response.data.stream_count"
      rename = "stream_count"
      type = "int"
    [[inputs.http.json_v2.field]]
      path = "response.data.stream_count_transcode"
      rename = "transcode_count"
      type = "int"
    [[inputs.http.json_v2.field]]
      path = "response.data.stream_count_direct_play"
      rename = "direct_play_count"
      type = "int"
    [[inputs.http.json_v2.field]]
      path = "response.data.stream_count_direct_stream"
      rename = "direct_stream_count"
      type = "int"
    [[inputs.http.json_v2.field]]
      path = "response.data.total_bandwidth"
      rename = "total_bandwidth"
      type = "int"
{% endif %}

# ============================================================================
# Vault — Seal status and health
# ============================================================================
[[inputs.http]]
  urls = ["https://{{ vault_ip }}:8200/v1/sys/health"]
  method = "GET"
  interval = "30s"
  timeout = "5s"
  insecure_skip_verify = true
  # Vault returns 200=unsealed+active, 429=unsealed+standby, 472=dr-standby, 473=perf-standby, 501=uninitialized, 503=sealed
  success_status_codes = [200, 429, 472, 473, 501, 503]
  data_format = "json_v2"
  name_override = "vault_health"
  [[inputs.http.json_v2]]
    [[inputs.http.json_v2.field]]
      path = "sealed"
      type = "boolean"
    [[inputs.http.json_v2.field]]
      path = "initialized"
      type = "boolean"
    [[inputs.http.json_v2.field]]
      path = "standby"
      type = "boolean"
    [[inputs.http.json_v2.field]]
      path = "server_time_utc"
      type = "int"
    [[inputs.http.json_v2.field]]
      path = "version"
      type = "string"

[[outputs.influxdb_v2]]
 ## The URLs of the InfluxDB cluster nodes.
 ##
 ## Multiple URLs can be specified for a single cluster, only ONE of the
 ## urls will be written to each interval.
 ## urls exp: http://127.0.0.1:9999
 ## Use internal Docker network IP for reliable local writes
 urls = ["http://{{ influxdb_ip }}:8086"]

 ## Token for authentication.
 token = "{{ vault_influxdb_telegraf_token | default(lookup('env', 'INFLUXDB_TELEGRAF_TOKEN')) }}"

 ## Organization is the name of the organization you wish to write to; must exist.
 organization = "homelab"

 ## Destination bucket to write into.
 bucket = "metrics"

{% if vault_openclaw_clawrouter_wallet_address is defined and vault_openclaw_clawrouter_wallet_address %}
# ClawRouter USDC wallet balance on Base
[[inputs.exec]]
  commands = ["/etc/telegraf/scripts/clawrouter-balance.sh"]
  timeout = "10s"
  data_format = "influx"
  interval = "30s"
  environment = ["CLAWROUTER_WALLET_ADDRESS={{ vault_openclaw_clawrouter_wallet_address }}"]
{% endif %}

